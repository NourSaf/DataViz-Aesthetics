{
  "version": 3,
  "sources": ["../../../../../../../../../node_modules/src/.internal/core/util/EventDispatcher.ts", "../../../../../../../../../node_modules/src/.internal/core/util/List.ts", "../../../../../../../../../node_modules/src/.internal/core/util/Children.ts"],
  "sourcesContent": ["/**\n * Event Dispatcher module is used for registering listeners and dispatching\n * events across amCharts system.\n */\n\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport { Disposer, IDisposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n\n/**\n * @ignore\n */\nexport type Events<Target, T> = {\n\t[K in keyof T]: T[K] & { type: K, target: Target }\n};\n\n/**\n * A universal interface for event listeners.\n *\n * @ignore\n */\nexport interface EventListener {\n\tkilled: boolean;\n\tonce: boolean;\n\ttype: any | null;\n\tcallback: (event: any) => void;\n\tcontext: unknown;\n\tshouldClone: boolean;\n\tdispatch: (type: any, event: any) => void;\n\tdisposer: IDisposer;\n}\n\n/**\n * Universal Event Dispatcher.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\n */\nexport class EventDispatcher<T> implements IDisposer {\n\tprotected _listeners: Array<EventListener>;\n\tprotected _killed: Array<EventListener>;\n\tprotected _disabled: { [key in keyof T]?: number };\n\tprotected _iterating: number;\n\tprotected _enabled: boolean;\n\tprotected _disposed: boolean;\n\n\n\t/**\n\t * Constructor\n\t */\n\tconstructor() {\n\t\tthis._listeners = [];\n\t\tthis._killed = [];\n\t\tthis._disabled = {};\n\t\tthis._iterating = 0;\n\t\tthis._enabled = true;\n\t\tthis._disposed = false;\n\t}\n\n\t/**\n\t * Returns if this object has been already disposed.\n\t *\n\t * @return Disposed?\n\t */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Dispose (destroy) this object.\n\t */\n\tpublic dispose(): void {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\tconst a = this._listeners;\n\n\t\t\tthis._iterating = 1;\n\t\t\tthis._listeners = <any>null;\n\t\t\tthis._disabled = <any>null;\n\n\t\t\ttry {\n\t\t\t\t$array.each(a, (x) => {\n\t\t\t\t\tx.disposer.dispose();\n\t\t\t\t});\n\n\t\t\t} finally {\n\t\t\t\tthis._killed = <any>null;\n\t\t\t\tthis._iterating = <any>null;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if this particular event dispatcher has any listeners set.\n\t *\n\t * @return Has listeners?\n\t */\n\tpublic hasListeners(): boolean {\n\t\treturn this._listeners.length !== 0;\n\t}\n\n\t/**\n\t * Checks if this particular event dispatcher has any particular listeners set.\n\t *\n\t * @return Has particular event listeners?\n\t */\n\tpublic hasListenersByType<Key extends keyof T>(type: Key): boolean {\n\t\treturn $array.any(this._listeners, (x) => (x.type === null || x.type === type) && !x.killed);\n\t}\n\n\t/**\n\t * Enable dispatching of events if they were previously disabled by\n\t * `disable()`.\n\t */\n\tpublic enable(): void {\n\t\tthis._enabled = true;\n\t}\n\n\t/**\n\t * Disable dispatching of events until re-enabled by `enable()`.\n\t */\n\tpublic disable(): void {\n\t\tthis._enabled = false;\n\t}\n\n\t/**\n\t * Enable dispatching particular event, if it was disabled before by\n\t * `disableType()`.\n\t *\n\t * @param type Event type\n\t */\n\tpublic enableType<Key extends keyof T>(type: Key): void {\n\t\tdelete this._disabled[type];\n\t}\n\n\t/**\n\t * Disable dispatching of events for a certain event type.\n\t *\n\t * Optionally, can set how many dispatches to skip before automatically\n\t * re-enabling the dispatching.\n\t *\n\t * @param type    Event type\n\t * @param amount  Number of event dispatches to skip\n\t */\n\tpublic disableType<Key extends keyof T>(type: Key, amount: number = Infinity): void {\n\t\tthis._disabled[type] = amount;\n\t}\n\n\t/**\n\t * Removes listener from dispatcher.\n\t *\n\t * Will throw an exception if such listener does not exists.\n\t *\n\t * @param listener Listener to remove\n\t */\n\tprotected _removeListener(listener: EventListener): void {\n\t\tif (this._iterating === 0) {\n\t\t\tconst index = this._listeners.indexOf(listener);\n\n\t\t\tif (index === -1) {\n\t\t\t\tthrow new Error(\"Invalid state: could not remove listener\");\n\t\t\t}\n\n\t\t\tthis._listeners.splice(index, 1);\n\n\t\t} else {\n\t\t\tthis._killed.push(listener);\n\t\t}\n\t}\n\n\t/**\n\t * Removes existing listener by certain parameters.\n\t *\n\t * @param once         Listener's once setting\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t */\n\tprotected _removeExistingListener<C, Key extends keyof T>(once: boolean, type: Key | null, callback?: (this: C, event: T[Key]) => void, context?: C): void {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._eachListener((info) => {\n\t\t\tif (info.once === once && // TODO is this correct ?\n\t\t\t\tinfo.type === type &&\n\t\t\t\t(callback === undefined || info.callback === callback) &&\n\t\t\t\tinfo.context === context) {\n\t\t\t\tinfo.disposer.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if dispatching for particular event type is enabled.\n\t *\n\t * @param type  Event type\n\t * @return Enabled?\n\t */\n\tpublic isEnabled<Key extends keyof T>(type: Key): boolean {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\t// TODO is this check correct ?\n\t\treturn this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n\t}\n\n\t/**\n\t * Removes all listeners of a particular event type\n\t *\n\t * @param type  Listener's type\n\t */\n\tpublic removeType<Key extends keyof T>(type: Key): void {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._eachListener((info) => {\n\t\t\tif (info.type === type) {\n\t\t\t\tinfo.disposer.dispose();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Checks if there's already a listener with specific parameters.\n\t *\n\t * @param type      Listener's type\n\t * @param callback  Callback function\n\t * @param context   Callback context\n\t * @return Has listener?\n\t */\n\tpublic has<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): boolean {\n\t\tconst index = $array.findIndex(this._listeners, (info) => {\n\t\t\treturn info.once !== true && // Ignoring \"once\" listeners\n\t\t\t\tinfo.type === type &&\n\t\t\t\t(callback === undefined || info.callback === callback) &&\n\t\t\t\tinfo.context === context;\n\t\t});\n\n\t\treturn index !== -1;\n\t}\n\n\t/**\n\t * Checks whether event of the particular type should be dispatched.\n\t *\n\t * @param type  Event type\n\t * @return Dispatch?\n\t */\n\tprotected _shouldDispatch<Key extends keyof T>(type: Key): boolean {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tconst count = this._disabled[type];\n\n\t\tif (!$type.isNumber(count)) {\n\t\t\treturn this._enabled;\n\n\t\t} else {\n\t\t\tif (count <= 1) {\n\t\t\t\tdelete this._disabled[type];\n\n\t\t\t} else {\n\t\t\t\t--this._disabled[type]!;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * [_eachListener description]\n\t *\n\t * All of this extra code is needed when a listener is removed while iterating\n\t *\n\t * @todo Description\n\t * @param fn [description]\n\t */\n\tprotected _eachListener(fn: (listener: EventListener) => void): void {\n\t\t++this._iterating;\n\n\t\ttry {\n\t\t\t$array.each(this._listeners, fn);\n\n\t\t} finally {\n\t\t\t--this._iterating;\n\n\t\t\t// TODO should this be inside or outside the finally ?\n\t\t\tif (this._iterating === 0 && this._killed.length !== 0) {\n\t\t\t\t// Remove killed listeners\n\t\t\t\t$array.each(this._killed, (killed) => {\n\t\t\t\t\tthis._removeListener(killed);\n\t\t\t\t});\n\n\t\t\t\tthis._killed.length = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Dispatches an event immediately without waiting for next cycle.\n\t *\n\t * @param type   Event type\n\t * @param event  Event object\n\t * @todo automatically add in type and target properties if they are missing\n\t */\n\tpublic dispatch<Key extends keyof T>(type: Key, event: T[Key]): void {\n\t\tif (this._shouldDispatch(type)) {\n\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\n\t\t\t// TODO if the function throws, maybe it should keep going ?\n\t\t\tthis._eachListener((listener) => {\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\n\t\t\t\t\tlistener.dispatch(type, event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Shelves the event to be dispatched within next update cycle.\n\t *\n\t * @param type   Event type\n\t * @param event  Event object\n\t * @todo automatically add in type and target properties if they are missing\n\t */\n\t/*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\n\t\tif (this._shouldDispatch(type)) {\n\t\t\tthis._eachListener((listener) => {\n\t\t\t\t// TODO check if it's faster to use an object of listeners rather than a single big array\n\t\t\t\tif (!listener.killed && (listener.type === null || listener.type === type)) {\n\t\t\t\t\t// TODO if the function throws, maybe it should keep going ?\n\t\t\t\t\t// TODO dispatch during the update cycle, rather than using whenIdle\n\t\t\t\t\t$async.whenIdle(() => {\n\t\t\t\t\t\tif (!listener.killed) {\n\t\t\t\t\t\t\tlistener.dispatch(type, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}*/\n\n\t/**\n\t * Creates, catalogs and returns an [[EventListener]].\n\t *\n\t * Event listener can be disposed.\n\t *\n\t * @param once         Listener's once setting\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @param dispatch\n\t * @returns An event listener\n\t */\n\tprotected _on<C, Key extends keyof T>(once: boolean, type: Key | null, callback: any, context: C, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tthis._removeExistingListener(once, type, callback, context);\n\n\t\tconst info: EventListener = {\n\t\t\ttype: type,\n\t\t\tcallback: callback,\n\t\t\tcontext: context,\n\t\t\tshouldClone: shouldClone,\n\t\t\tdispatch: <any>dispatch,\n\t\t\tkilled: false,\n\t\t\tonce: once,\n\t\t\tdisposer: new Disposer(() => {\n\t\t\t\tinfo.killed = true;\n\t\t\t\tthis._removeListener(info);\n\t\t\t})\n\t\t};\n\n\t\tthis._listeners.push(info);\n\n\t\treturn info;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on **any** event.\n\t *\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic onAll<C, K extends keyof T>(callback: (this: C, event: T[K]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\treturn this._on(false, null, callback, context, shouldClone, (_type, event) => (<any>callback).call(context, event as any)).disposer;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on a specific event type.\n\t *\n\t * ```TypeScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t * ```JavaScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t *\n\t * The above will invoke our custom event handler whenever series we put\n\t * event on is hidden.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic on<C, Key extends keyof T>(type: Key, callback: (this: C | undefined, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\treturn this._on(false, type, callback, context, shouldClone, (_type, event) => callback.call(context, event)).disposer;\n\t}\n\n\t/**\n\t * Creates an event listener to be invoked on a specific event type once.\n\t *\n\t * Once the event listener is invoked, it is automatically disposed.\n\t *\n\t * ```TypeScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t * ```JavaScript\n\t * button.events.once(\"click\", (ev) => {\n\t *   console.log(\"Button clicked\");\n\t * }, this);\n\t * ```\n\t *\n\t * The above will invoke our custom event handler the first time series we\n\t * put event on is hidden.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\n\t * @returns A disposable event listener\n\t */\n\tpublic once<C, Key extends keyof T>(type: Key, callback: (this: C | undefined, event: T[Key]) => void, context?: C, shouldClone: boolean = true): IDisposer {\n\t\tconst x = this._on(true, type, callback, context, shouldClone, (_type, event) => {\n\t\t\tx.disposer.dispose();\n\t\t\tcallback.call(context, event)\n\t\t});\n\n\t\t// TODO maybe this should return a different Disposer ?\n\t\treturn x.disposer;\n\t}\n\n\t/**\n\t * Removes the event listener with specific parameters.\n\t *\n\t * @param type         Listener's type\n\t * @param callback     Callback function\n\t * @param context      Callback context\n\t */\n\tpublic off<C, Key extends keyof T>(type: Key, callback?: (this: C, event: T[Key]) => void, context?: C): void {\n\t\tthis._removeExistingListener(false, type, callback, context);\n\t}\n\n\n\t/**\n\t * Copies all dispatcher parameters, including listeners, from another event\n\t * dispatcher.\n\t *\n\t * @param source Source event dispatcher\n\t * @ignore\n\t */\n\tpublic copyFrom(source: this): IDisposer {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tif (source === this) {\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n\t\t}\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$array.each(source._listeners, (x) => {\n\t\t\t// TODO is this correct ?\n\t\t\tif (!x.killed && x.shouldClone) {\n\t\t\t\tif (x.type === null) {\n\t\t\t\t\tdisposers.push(this.onAll(x.callback as any, x.context));\n\n\t\t\t\t} else if (x.once) {\n\t\t\t\t\tdisposers.push(this.once(x.type, x.callback, x.context));\n\n\t\t\t\t} else {\n\t\t\t\t\tdisposers.push(this.on(x.type, x.callback, x.context));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n}\n\n/**\n * A version of the [[EventDispatcher]] that dispatches events for a specific\n * target object.\n *\n * @ignore\n */\nexport class TargetedEventDispatcher<Target, T> extends EventDispatcher<T> {\n\n\t/**\n\t * A target object which is originating events using this dispatcher.\n\t */\n\tpublic target: Target;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param target Event dispatcher target\n\t */\n\tconstructor(target: Target) {\n\t\tsuper();\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * Copies all dispatcher parameters, including listeners, from another event\n\t * dispatcher.\n\t *\n\t * @param source Source event dispatcher\n\t * @ignore\n\t */\n\tpublic copyFrom(source: this): IDisposer {\n\t\tif (this._disposed) {\n\t\t\tthrow new Error(\"EventDispatcher is disposed\");\n\t\t}\n\n\t\tif (source === this) {\n\t\t\tthrow new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n\t\t}\n\n\t\tconst disposers: Array<IDisposer> = [];\n\n\t\t$array.each(source._listeners, (x) => {\n\t\t\t// TODO very hacky\n\t\t\tif (x.context === source.target) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// TODO is this correct ?\n\t\t\tif (!x.killed && x.shouldClone) {\n\t\t\t\tif (x.type === null) {\n\t\t\t\t\tdisposers.push(this.onAll(x.callback as any, x.context));\n\n\t\t\t\t} else if (x.once) {\n\t\t\t\t\tdisposers.push(this.once(x.type, x.callback, x.context));\n\n\t\t\t\t} else {\n\t\t\t\t\tdisposers.push(this.on(x.type, x.callback, x.context));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn new MultiDisposer(disposers);\n\t}\n\n}\n", "/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\nimport type { Entity } from \"./Entity\";\nimport type { Template } from \"./Template\";\nimport type { IDisposer } from \"./Disposer\";\nimport { EventDispatcher, Events } from \"./EventDispatcher\";\nimport * as $array from \"./Array\";\nimport type { Optional } from \"./Type\";\n\n\n/**\n * Checks if specific index fits into length.\n *\n * @param index  Index\n * @param len    Length\n * @ignore\n */\nfunction checkBounds(index: number, len: number): void {\n\tif (!(index >= 0 && index < len)) {\n\t\tthrow new Error(\"Index out of bounds: \" + index);\n\t}\n}\n\n\nexport interface IListEvents<A> {\n\tclear: {\n\t\toldValues: Array<A>,\n\t};\n\tpush: {\n\t\tnewValue: A,\n\t};\n\tinsertIndex: {\n\t\tindex: number,\n\t\tnewValue: A,\n\t};\n\tsetIndex: {\n\t\tindex: number,\n\t\toldValue: A,\n\t\tnewValue: A,\n\t};\n\tremoveIndex: {\n\t\tindex: number,\n\t\toldValue: A,\n\t};\n\tmoveIndex: {\n\t\toldIndex: number,\n\t\tnewIndex: number,\n\t\tvalue: A,\n\t};\n}\n\n\n/**\n * A List class is used to hold a number of indexed items of the same type.\n */\nexport class List<T> {\n\n\t/**\n\t * List values.\n\t */\n\tprotected _values: Array<T>;\n\n\tpublic events: EventDispatcher<Events<this, IListEvents<T>>> = new EventDispatcher();\n\n\t/**\n\t * Constructor\n\t *\n\t * @param initial  Inital list of values to add to list\n\t */\n\tconstructor(initial: Array<T> = []) {\n\t\tthis._values = initial;\n\t}\n\n\t/**\n\t * An array of values in the list.\n\t *\n\t * Do not use this property to add values. Rather use dedicated methods, like\n\t * `push()`, `removeIndex()`, etc.\n\t *\n\t * @readonly\n\t * @return List values\n\t */\n\tpublic get values(): Array<T> {\n\t\treturn this._values;\n\t}\n\n\t/**\n\t * Checks if list contains specific item reference.\n\t *\n\t * @param item  Item to search for\n\t * @return `true` if found, `false` if not found\n\t */\n\tpublic contains(value: T): boolean {\n\t\treturn this._values.indexOf(value) !== -1;\n\t}\n\n\t/**\n\t * Removes specific item from the list.\n\t *\n\t * @param item An item to remove\n\t */\n\tpublic removeValue(value: T): void {\n\t\tlet i = 0;\n\t\tlet length = this._values.length;\n\n\t\twhile (i < length) {\n\t\t\t// TODO handle NaN\n\t\t\tif (this._values[i] === value) {\n\t\t\t\tthis.removeIndex(i);\n\t\t\t\t--length;\n\n\t\t\t} else {\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Searches the list for specific item and returns its index.\n\t *\n\t * @param item  An item to search for\n\t * @return Index or -1 if not found\n\t */\n\tpublic indexOf(value: T): number {\n\t\treturn $array.indexOf(this._values, value);\n\t}\n\n\t/**\n\t * Number of items in list.\n\t *\n\t * @readonly\n\t * @return Number of items\n\t */\n\tpublic get length(): number {\n\t\treturn this._values.length;\n\t}\n\n\t/**\n\t * Checks if there's a value at specific index.\n\t *\n\t * @param index  Index\n\t * @return Value exists?\n\t */\n\tpublic hasIndex(index: number): boolean {\n\t\treturn index >= 0 && index < this._values.length;\n\t}\n\n\t/**\n\t * Returns an item at specified index.\n\t *\n\t * @param index  Index\n\t * @return List item\n\t */\n\tpublic getIndex(index: number): T | undefined {\n\t\treturn this._values[index];\n\t}\n\n\tprotected _onPush(newValue: T) {\n\t\tif (this.events.isEnabled(\"push\")) {\n\t\t\tthis.events.dispatch(\"push\", {\n\t\t\t\ttype: \"push\",\n\t\t\t\ttarget: this,\n\t\t\t\tnewValue\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected _onInsertIndex(index: number, newValue: T) {\n\t\tif (this.events.isEnabled(\"insertIndex\")) {\n\t\t\tthis.events.dispatch(\"insertIndex\", {\n\t\t\t\ttype: \"insertIndex\",\n\t\t\t\ttarget: this,\n\t\t\t\tindex,\n\t\t\t\tnewValue\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected _onSetIndex(index: number, oldValue: T, newValue: T) {\n\t\tif (this.events.isEnabled(\"setIndex\")) {\n\t\t\tthis.events.dispatch(\"setIndex\", {\n\t\t\t\ttype: \"setIndex\",\n\t\t\t\ttarget: this,\n\t\t\t\tindex,\n\t\t\t\toldValue,\n\t\t\t\tnewValue\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected _onRemoveIndex(index: number, oldValue: T) {\n\t\tif (this.events.isEnabled(\"removeIndex\")) {\n\t\t\tthis.events.dispatch(\"removeIndex\", {\n\t\t\t\ttype: \"removeIndex\",\n\t\t\t\ttarget: this,\n\t\t\t\tindex,\n\t\t\t\toldValue\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected _onMoveIndex(oldIndex: number, newIndex: number, value: T) {\n\t\tif (this.events.isEnabled(\"moveIndex\")) {\n\t\t\tthis.events.dispatch(\"moveIndex\", {\n\t\t\t\ttype: \"moveIndex\",\n\t\t\t\ttarget: this,\n\t\t\t\toldIndex,\n\t\t\t\tnewIndex,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t}\n\n\tprotected _onClear(oldValues: Array<T>) {\n\t\tif (this.events.isEnabled(\"clear\")) {\n\t\t\tthis.events.dispatch(\"clear\", {\n\t\t\t\ttype: \"clear\",\n\t\t\t\ttarget: this,\n\t\t\t\toldValues\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Sets value at specific index.\n\t *\n\t * If there's already a value at the index, it is overwritten.\n\t *\n\t * @param index  Index\n\t * @param value  New value\n\t * @return New value\n\t */\n\tpublic setIndex(index: number, value: T): T {\n\t\tcheckBounds(index, this._values.length);\n\n\t\tconst oldValue = this._values[index];\n\n\t\t// Do nothing if the old value and the new value are the same\n\t\tif (oldValue !== value) {\n\t\t\tthis._values[index] = value;\n\t\t\tthis._onSetIndex(index, oldValue, value);\n\t\t}\n\n\t\treturn oldValue;\n\t}\n\n\t/**\n\t * Adds an item to the list at a specific index, which pushes all the other\n\t * items further down the list.\n\t *\n\t * @param index Index\n\t * @param item  An item to add\n\t */\n\tpublic insertIndex<K extends T>(index: number, value: K): K {\n\t\tcheckBounds(index, this._values.length + 1);\n\n\t\t$array.insertIndex(this._values, index, value);\n\t\tthis._onInsertIndex(index, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Swaps indexes of two items in the list.\n\t *\n\t * @param a  Item 1\n\t * @param b  Item 2\n\t */\n\tpublic swap(a: number, b: number): void {\n\t\tconst len = this._values.length;\n\n\t\tcheckBounds(a, len);\n\t\tcheckBounds(b, len);\n\n\t\tif (a !== b) {\n\t\t\tconst value_a = this._values[a];\n\t\t\tconst value_b = this._values[b];\n\n\t\t\tthis._values[a] = value_b;\n\t\t\tthis._onSetIndex(a, value_a, value_b);\n\n\t\t\tthis._values[b] = value_a;\n\t\t\tthis._onSetIndex(b, value_b, value_a);\n\t\t}\n\t}\n\n\t/**\n\t * Removes a value at specific index.\n\t *\n\t * @param index  Index of value to remove\n\t * @return Removed value\n\t */\n\tpublic removeIndex(index: number): T {\n\t\tcheckBounds(index, this._values.length);\n\n\t\tconst oldValue = this._values[index];\n\n\t\t$array.removeIndex(this._values, index);\n\t\tthis._onRemoveIndex(index, oldValue);\n\n\t\treturn oldValue;\n\t}\n\n\t/**\n\t * Moves an item to a specific index within the list.\n\t *\n\t * If the index is not specified it will move the item to the end of the\n\t * list.\n\t *\n\t * @param value  Item to move\n\t * @param index  Index to place item at\n\t */\n\tpublic moveValue<K extends T>(value: K, toIndex?: number): K {\n\t\t// TODO don't do anything if the desired index is the same as the current index\n\t\tlet index = this.indexOf(value);\n\n\t\t// TODO remove all old values rather than only the first ?\n\t\tif (index !== -1) {\n\t\t\t$array.removeIndex(this._values, index);\n\n\t\t\tif (toIndex == null) {\n\t\t\t\tconst toIndex = this._values.length;\n\t\t\t\tthis._values.push(value);\n\t\t\t\tthis._onMoveIndex(index, toIndex, value);\n\n\t\t\t} else {\n\t\t\t\t$array.insertIndex(this._values, toIndex, value);\n\t\t\t\tthis._onMoveIndex(index, toIndex, value);\n\t\t\t}\n\n\t\t} else if (toIndex == null) {\n\t\t\tthis._values.push(value);\n\t\t\tthis._onPush(value);\n\n\t\t} else {\n\t\t\t$array.insertIndex(this._values, toIndex, value);\n\t\t\tthis._onInsertIndex(toIndex, value);\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Adds an item to the end of the list.\n\t *\n\t * @param item  An item to add\n\t */\n\tpublic push<K extends T>(value: K): K {\n\t\tthis._values.push(value);\n\t\tthis._onPush(value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Adds an item as a first item in the list.\n\t *\n\t * @param item  An item to add\n\t */\n\tpublic unshift<K extends T>(value: K): K {\n\t\tthis.insertIndex(0, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Adds multiple items to the list.\n\t *\n\t * @param items  An Array of items to add\n\t */\n\tpublic pushAll(values: Array<T>): void {\n\t\t$array.each(values, (value) => {\n\t\t\tthis.push(value);\n\t\t});\n\t}\n\n\t/**\n\t * Copies and adds items from abother list.\n\t *\n\t * @param source  A list top copy items from\n\t */\n\tpublic copyFrom(source: this): void {\n\t\tthis.pushAll(source._values);\n\t}\n\n\t/**\n\t * Returns the last item from the list, and removes it.\n\t *\n\t * @return Item\n\t */\n\tpublic pop(): Optional<T> {\n\t\tlet index = this._values.length - 1;\n\t\treturn index < 0 ? undefined : this.removeIndex(this._values.length - 1);\n\t}\n\n\t/**\n\t * Returns the first item from the list, and removes it.\n\t *\n\t * @return Item\n\t */\n\tpublic shift(): Optional<T> {\n\t\treturn this._values.length ? this.removeIndex(0) : undefined;\n\t}\n\n\t/**\n\t * Sets multiple items to the list.\n\t *\n\t * All current items are removed.\n\t *\n\t * @param newArray  New items\n\t */\n\tpublic setAll(newArray: Array<T>): void {\n\t\tconst old = this._values;\n\t\tthis._values = [];\n\t\tthis._onClear(old);\n\n\t\t$array.each(newArray, (value) => {\n\t\t\tthis._values.push(value);\n\t\t\tthis._onPush(value);\n\t\t});\n\t}\n\n\t/**\n\t * Removes all items from the list.\n\t */\n\tpublic clear(): void {\n\t\tthis.setAll([]);\n\t}\n\n\t/**\n\t * Returns an ES6 iterator for the list.\n\t */\n\tpublic *[Symbol.iterator](): Iterator<T> {\n\t\tconst length = this._values.length;\n\n\t\tfor (let i = 0; i < length; ++i) {\n\t\t\tyield this._values[i];\n\t\t}\n\t}\n\n\t/**\n\t * Calls `f` for each element in the list.\n\t *\n\t * `f` should have at least one parameter defined which will get a current\n\t * item, with optional second argument - index.\n\t */\n\tpublic each(f: (value: T, index: number) => void): void {\n\t\t$array.each(this._values, f);\n\t}\n\n\t/**\n\t * Calls `f` for each element in the list, from right to left.\n\t *\n\t * `f` should have at least one parameter defined which will get a current\n\t * item, with optional second argument - index.\n\t */\n\tpublic eachReverse(f: (value: T, index: number) => void): void {\n\t\t$array.eachReverse(this._values, f);\n\t}\n}\n\n\n/**\n * A version of a [[List]] where the elements are disposed automatically when\n * removed from the list, unless `autoDispose` is set to `false`.\n */\nexport class ListAutoDispose<A extends IDisposer> extends List<A> implements IDisposer {\n\t/**\n\t * Automatically disposes elements that are removed from the list.\n\t *\n\t * @default true\n\t */\n\tpublic autoDispose: boolean = true;\n\n\tprivate _disposed: boolean = false;\n\n\tprotected _onSetIndex(index: number, oldValue: A, newValue: A) {\n\t\tif (this.autoDispose) {\n\t\t\toldValue.dispose();\n\t\t}\n\n\t\tsuper._onSetIndex(index, oldValue, newValue);\n\t}\n\n\tprotected _onRemoveIndex(index: number, oldValue: A) {\n\t\tif (this.autoDispose) {\n\t\t\toldValue.dispose();\n\t\t}\n\n\t\tsuper._onRemoveIndex(index, oldValue);\n\t}\n\n\tprotected _onClear(oldValues: Array<A>) {\n\t\tif (this.autoDispose) {\n\t\t\t$array.each(oldValues, (x) => {\n\t\t\t\tx.dispose();\n\t\t\t});\n\t\t}\n\n\t\tsuper._onClear(oldValues);\n\t}\n\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\tpublic dispose(): void {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\tif (this.autoDispose) {\n\t\t\t\t$array.each(this._values, (x) => {\n\t\t\t\t\tx.dispose();\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * A version of a [[List]] that is able to create new elements as well as\n * apply additional settings to newly created items.\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/list-templates/} for more info\n */\nexport class ListTemplate<A extends Entity> extends ListAutoDispose<A> {\n\tpublic template: Template<A>;\n\tpublic make: () => A;\n\n\tconstructor(template: Template<A>, make: () => A) {\n\t\tsuper();\n\t\tthis.template = template;\n\t\tthis.make = make;\n\t}\n}\n", "import { List } from \"./List\";\nimport type { IDisposer } from \"./Disposer\";\nimport type { Container } from \"../render/Container\";\nimport type { Sprite } from \"../render/Sprite\";\nimport * as $array from \"./Array\";\n\n/**\n * A version of [[List]] to hold children of the [[Container]].\n *\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/containers/} for more info\n */\nexport class Children<A extends Sprite> extends List<A> implements IDisposer {\n\tprivate _disposed: boolean = false;\n\tprivate _container: Container;\n\tprivate _events: IDisposer;\n\n\tpublic constructor(container: Container) {\n\t\tsuper();\n\n\t\tthis._container = container;\n\n\t\tthis._events = this.events.onAll((change) => {\n\t\t\tif (change.type === \"clear\") {\n\t\t\t\t$array.each(change.oldValues, (x) => {\n\t\t\t\t\tthis._onRemoved(x);\n\t\t\t\t});\n\n\t\t\t} else if (change.type === \"push\") {\n\t\t\t\tthis._onInserted(change.newValue);\n\n\t\t\t} else if (change.type === \"setIndex\") {\n\t\t\t\tthis._onRemoved(change.oldValue);\n\t\t\t\tthis._onInserted(change.newValue, change.index);\n\n\t\t\t} else if (change.type === \"insertIndex\") {\n\t\t\t\tthis._onInserted(change.newValue, change.index);\n\n\t\t\t} else if (change.type === \"removeIndex\") {\n\t\t\t\tthis._onRemoved(change.oldValue);\n\n\t\t\t} else if (change.type === \"moveIndex\") {\n\t\t\t\tthis._onRemoved(change.value);\n\t\t\t\tthis._onInserted(change.value, change.newIndex);\n\n\t\t\t} else {\n\t\t\t\tthrow new Error(\"Unknown IListEvent type\");\n\t\t\t}\n\t\t});\n\t}\n\n\tprotected _onInserted(child: A, index?: number) {\n\t\tchild._setParent(this._container, true);\n\t\tconst childrenDisplay = this._container._childrenDisplay;\n\t\tif (index === undefined) {\n\t\t\tchildrenDisplay.addChild(child._display);\n\n\t\t} else {\n\t\t\tchildrenDisplay.addChildAt(child._display, index);\n\t\t}\n\t}\n\n\tprotected _onRemoved(child: A) {\n\t\tthis._container._childrenDisplay.removeChild(child._display);\n\t\tthis._container.markDirtyBounds();\n\t\tthis._container.markDirty();\n\t}\n\n\t/**\n\t * Returns `true` if obejct is disposed.\n\t */\n\tpublic isDisposed(): boolean {\n\t\treturn this._disposed;\n\t}\n\n\t/**\n\t * Permanently dispose this object.\n\t */\n\tpublic dispose() {\n\t\tif (!this._disposed) {\n\t\t\tthis._disposed = true;\n\n\t\t\tthis._events.dispose();\n\n\t\t\t$array.each(this.values, (child) => {\n\t\t\t\tchild.dispose();\n\t\t\t});\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": ["toIndex"]
}
